/*
Copyright (C) 2017-2020 Topological Manifold

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//   Создание загрузочных функций OpenGL из файла glcorearb.h.
//   Вызов функции glXGetProcAddress записывается в отдельный файл,
// чтобы не было в одном файле #include <GL/glcorearb.h> и #include <GL/glx.h>.
//   Получаемые от glXGetProcAddress адреса не зависят от контекста,
// поэтому достаточно иметь глобальные переменные.

#include <cctype>
#include <fstream>
#include <iostream>
#include <random>
#include <regex>
#include <string>
#include <vector>

constexpr const char* NAMESPACE = "opengl_functions";
constexpr const char* FUNCTIONS_FILE = "functions";
constexpr const char* FUNCTIONS_PROC_FILE = "functions_proc";
constexpr const char* POINTER_PREFIX = "";
constexpr const char* INDENT = "        ";

namespace
{
struct FuncData
{
        std::string pointer_type;
        std::string pointer_name;
        std::string function_name;
        std::string return_type;
        std::string return_statement;
        std::string parameter_decl;
        std::string parameter_names;
};

[[noreturn]] void error(const std::string& msg)
{
        std::cerr << msg << std::endl;
        std::exit(EXIT_FAILURE);
}

std::string trim(const std::string& s)
{
        if (s.size() == 0)
        {
                return s;
        }

        size_t n = s.size();
        size_t i = 0;
        while (i < n && std::isspace(s[i]))
        {
                ++i;
        }
        if (i == n)
        {
                return std::string();
        }

        size_t ri = s.size() - 1;
        while (std::isspace(s[ri]))
        {
                if (ri == 0)
                {
                        error("trim error from string: " + s);
                }
                --ri;
        }

        return s.substr(i, ri - i + 1);
}

std::string to_upper(const std::string& str)
{
        std::string r;
        for (char c : str)
        {
                r += std::toupper(c);
        }
        return r;
}

void create_data(const std::string& function_name, const std::string& return_type, const std::string& parameter_decl,
                 const std::string& parameter_names, std::vector<FuncData>* data)
{
        FuncData s;
        s.pointer_type = "PFN" + to_upper(function_name) + "PROC";
        s.pointer_name = POINTER_PREFIX + function_name;
        s.function_name = function_name;
        s.return_type = return_type;
        s.return_statement = return_type != "void" ? "return " : "";
        s.parameter_decl = parameter_decl != "void" ? parameter_decl : "";
        s.parameter_names = parameter_names != "void" ? parameter_names : "";
        data->push_back(std::move(s));
}

void write_data(const std::vector<FuncData>& data)
{
        int pointer_type_length = -1;
        int pointer_name_length = -1;
        for (const FuncData& s : data)
        {
                pointer_type_length = std::max(static_cast<int>(s.pointer_type.size()), pointer_type_length);
                pointer_name_length = std::max(static_cast<int>(s.pointer_name.size()), pointer_name_length);
        }

        std::ofstream f_proc_header(std::string(FUNCTIONS_PROC_FILE) + ".h");
        std::ofstream f_proc_impl(std::string(FUNCTIONS_PROC_FILE) + ".cpp");

        std::ofstream f_header(std::string(FUNCTIONS_FILE) + ".h");
        std::ofstream f_impl(std::string(FUNCTIONS_FILE) + ".cpp");

        if (!f_proc_header || !f_proc_impl || !f_header || !f_impl)
        {
                error("error open output files");
        }

        // functions_proc.h

        f_proc_header << "// Generated by program\n";
        f_proc_header << "\n";
        f_proc_header << "// clang-format off\n";
        f_proc_header << "\n";
        f_proc_header << "#pragma once\n";
        f_proc_header << "\n";
        f_proc_header << "namespace " << NAMESPACE << "\n";
        f_proc_header << "{\n";
        f_proc_header << INDENT << "using PTR = void (*)(void);\n";
        f_proc_header << INDENT << "PTR gl_proc_address(const char* str);\n";
        f_proc_header << "}\n";
        f_proc_header << "\n";
        f_proc_header << "// clang-format on\n";

        // functions_proc.cpp

        f_proc_impl << "// Generated by program\n";
        f_proc_impl << "\n";
        f_proc_impl << "// clang-format off\n";
        f_proc_impl << "\n";
        f_proc_impl << "#include \"" << FUNCTIONS_PROC_FILE << ".h\"\n";
        f_proc_impl << "\n";
        f_proc_impl << "#if defined(__linux__)\n";
        f_proc_impl << "\n";
        f_proc_impl << "#include <GL/glx.h>\n";
        f_proc_impl << "\n";
        f_proc_impl << NAMESPACE << "::PTR " << NAMESPACE << "::gl_proc_address(const char* str)\n";
        f_proc_impl << "{\n";
        f_proc_impl << INDENT << "return glXGetProcAddress(reinterpret_cast<const GLubyte*>(str));\n";
        f_proc_impl << "}\n";
        f_proc_impl << "\n";
        f_proc_impl << "#elif defined(_WIN32)\n";
        f_proc_impl << "\n";
        f_proc_impl << "#define WIN32_LEAN_AND_MEAN 1\n";
        f_proc_impl << "#include <windows.h>\n";
        f_proc_impl << "\n";
        f_proc_impl << NAMESPACE << "::PTR " << NAMESPACE << "::gl_proc_address(const char* str)\n";
        f_proc_impl << "{\n";
        f_proc_impl << INDENT << NAMESPACE << "::PTR ptr;\n";
        f_proc_impl << INDENT << "ptr = reinterpret_cast<" << NAMESPACE << "::PTR>(wglGetProcAddress(str));\n";
        f_proc_impl << INDENT << "if (!ptr)\n";
        f_proc_impl << INDENT << "{\n";
        f_proc_impl << INDENT << INDENT << "HMODULE module = LoadLibraryA(\"opengl32.dll\");\n";
        f_proc_impl << INDENT << INDENT << "ptr = reinterpret_cast<" << NAMESPACE << "::PTR>(GetProcAddress(module, str));\n";
        f_proc_impl << INDENT << INDENT << "FreeLibrary(module);\n";
        f_proc_impl << INDENT << "}\n";
        f_proc_impl << INDENT << "return ptr;\n";
        f_proc_impl << "}\n";
        f_proc_impl << "\n";
        f_proc_impl << "#else\n";
        f_proc_impl << "#error This operating system is not supported\n";
        f_proc_impl << "#endif\n";
        f_proc_impl << "\n";
        f_proc_impl << "// clang-format on\n";

        // functions.h первая часть с указателями

        f_header << "// Generated from glcorearb.h\n";
        f_header << "\n";
        f_header << "// clang-format off\n";
        f_header << "\n";
        f_header << "#pragma once\n";
        f_header << "\n";
        f_header << "#include <GL/glcorearb.h>\n";
        f_header << "\n";
        f_header << "#if defined(_WIN32)\n";
        f_header << "#undef near\n";
        f_header << "#undef far\n";
        f_header << "#endif\n";
        f_header << "\n";
        f_header << "namespace " << NAMESPACE << "\n";
        f_header << "{\n";
        f_header << INDENT << "void init();\n";
        f_header << "\n";
        for (const FuncData& s : data)
        {
                std::string padding = std::string(pointer_type_length - s.pointer_type.size(), ' ');

                f_header << INDENT << "extern " << s.pointer_type << padding << " " << s.pointer_name << ";\n";
        }
        f_header << "}\n";

        // functions.h вторая часть с функциями

        f_header << "\n";
        for (const FuncData& s : data)
        {
                f_header << "inline " << s.return_type << " " << s.function_name << "(" << s.parameter_decl << ") noexcept\n";
                f_header << "{\n";
                f_header << INDENT << s.return_statement << NAMESPACE << "::" << s.pointer_name << "(" << s.parameter_names
                         << ");\n";
                f_header << ("}\n");
        }
        f_header << "\n";
        f_header << "// clang-format on\n";

        // functions.cpp первая часть с функцией и указателями

        f_impl << "// Generated from glcorearb.h\n";
        f_impl << "\n";
        f_impl << "// clang-format off\n";
        f_impl << "\n";
        f_impl << "#include \"" << FUNCTIONS_FILE << ".h\"\n";
        f_impl << "\n";
        f_impl << "#include \"" << FUNCTIONS_PROC_FILE << ".h\"\n";
        f_impl << "\n";
        f_impl << "namespace\n";
        f_impl << "{\n";
        f_impl << "template<typename T>\n";
        f_impl << "void set(T* p, const char* s)\n";
        f_impl << "{\n";
        f_impl << "        *p = reinterpret_cast<T>(" << NAMESPACE << "::gl_proc_address(s));\n";
        f_impl << "}\n";
        f_impl << "}\n";
        f_impl << "\n";
        for (const FuncData& s : data)
        {
                std::string padding = std::string(pointer_type_length - s.pointer_type.size(), ' ');

                f_impl << s.pointer_type << padding << " " << NAMESPACE << "::" << s.pointer_name << ";\n";
        }

        // functions.cpp вторая часть с определением адресов функций

        f_impl << "\n";
        f_impl << "void " << NAMESPACE << "::init()\n";
        f_impl << "{\n";
        for (const FuncData& s : data)
        {
                std::string padding = std::string(pointer_name_length - s.pointer_name.size(), ' ');

                f_impl << INDENT << "set(&" << NAMESPACE << "::" << s.pointer_name << ", " << padding << "\"" << s.function_name
                       << "\");\n";
        }
        f_impl << "}\n";
        f_impl << "\n";
        f_impl << "// clang-format on\n";
}
}

int main(int argc, char* argv[])
{
        if (argc != 2)
        {
                error("Usage: program \"dir_with_glcorearb.h\"");
        }

        std::string str_func, str_ret, str_pdecl, str_pname;

        const std::regex re_function(str_func = R"(GLAPI.*APIENTRY\s+(\w+))");
        const std::regex re_return(str_ret = R"(GLAPI\s+(.+)(?=\s*APIENTRY))");
        const std::regex re_parameter_decl(str_pdecl = R"(GLAPI.*APIENTRY\s+\w+\s*\((.*)\))");
        const std::regex re_parameter_names(str_pname = R"((\w+(?=\s*[\[,)])))");

        std::smatch m;

        std::vector<FuncData> data;

        const std::string file_name = std::string(argv[1]) + "/glcorearb.h";
        std::ifstream file(file_name);
        if (!file)
        {
                error("Error open file " + file_name);
        }

        std::string s;
        while (std::getline(file, s))
        {
                if (!std::regex_search(s, m, re_function))
                {
                        continue;
                }
                std::string function_name = m[1];

                if (!std::regex_search(s, m, re_return))
                {
                        error("Return type not found in \"" + s + "\"" + ", regex \"" + str_ret + "\"");
                }
                std::string return_type = m[1];

                if (!std::regex_search(s, m, re_parameter_decl))
                {
                        error("Parameter decl not found in \"" + s + "\"" + ", regex \"" + str_pdecl + "\"");
                }
                std::string parameter_decl = m[1];

                std::string parameter_names;
                bool not_first = false;
                for (std::sregex_iterator p(s.begin(), s.end(), re_parameter_names); p != std::sregex_iterator{}; ++p)
                {
                        parameter_names += (not_first ? ", " : "") + std::string((*p)[1]);
                        not_first = true;
                }
                if (parameter_names.size() == 0)
                {
                        error("Parameter names not found in \"" + s + "\"" + ", regex \"" + str_pname + "\"");
                }

                create_data(trim(function_name), trim(return_type), trim(parameter_decl), trim(parameter_names), &data);
        }

        if (data.size() == 0)
        {
                error("Data not found in the file " + file_name);
        }

        std::sort(data.begin(), data.end(),
                  [](const FuncData& a, const FuncData& b) -> bool { return a.function_name < b.function_name; });

        write_data(data);

        return EXIT_SUCCESS;
}
