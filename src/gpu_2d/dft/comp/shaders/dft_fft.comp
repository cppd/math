/*
Copyright (C) 2017, 2018 Topological Manifold

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

// gl_GlobalInvocationID = gl_WorkGroupID * gl_LocalGroupSizeARB + gl_LocalInvocationID

layout(local_size_variable) in;

#if defined(function_reverse)

layout(location = 0) uniform uint max_threads;
layout(location = 1) uniform uint N_mask;
layout(location = 2) uniform uint N_bits;
layout(std430, binding = 0) buffer StorageBuffer
{
        complex data[];
};

void main()
{
        uint thread_id = gl_GlobalInvocationID.x;
        if (thread_id >= max_threads)
        {
                return;
        }
        uint i = thread_id & N_mask;
        uint N_base = thread_id - i;
        uint r = bit_reverse(i, N_bits);
        if (i < r) // для исключения одинаковых обменов и уже сделанных обменов
        {
                uint i_index = N_base + i;
                uint r_index = N_base + r;
                complex t = data[i_index];
                data[i_index] = data[r_index];
                data[r_index] = t;
        }
}

#endif

#if defined(function_FFT)

layout(location = 0) uniform uint inv;
layout(location = 1) uniform uint max_threads;
layout(location = 2) uniform uint N_2_mask;
layout(location = 3) uniform uint N_2_bits;
layout(location = 4) uniform uint M_2;
layout(location = 5) uniform float_point Two_PI_Div_M;
layout(std430, binding = 0) buffer StorageBuffer
{
        complex data[];
};

void main()
{
        uint thread_id = gl_GlobalInvocationID.x;
        if (thread_id >= max_threads)
        {
                return;
        }

        // номер задачи внутри одного БПФ
        uint i = thread_id & N_2_mask;
        // начало ДПФ
        uint N_base = (thread_id - i) << 1;

        uint idx = i & (M_2 - 1);
        uint base = (i - idx) << 1;

        uint index_t = N_base + base + idx;
        uint index_u = index_t + M_2;

        complex v_t = data[index_t];
        complex v_u = data[index_u];

        complex twiddle_factor = complex(cos(Two_PI_Div_M * idx), sin(Two_PI_Div_M * idx));

        complex k = mul(twiddle_factor, v_u);

        if (inv == 0)
        {
                data[index_t] = v_t + k;
                data[index_u] = v_t - k;
        }
        else
        {
                data[index_t] = (v_t + k) * 0.5;
                data[index_u] = (v_t - k) * 0.5;
        }
}

#endif

#if defined(function_FFT_radix_2)

layout(location = 0) uniform uint inv;
layout(location = 1) uniform uint MAX_DATA_SIZE;

layout(std430, binding = 0) buffer StorageBuffer
{
        complex global_data[];
};

// Вставляются в текст программы
// const uint N =
// const uint N_MASK =
// const uint N_BITS =
// const uint SHARED_SIZE =
// const bool REVERSE_INPUT =

// До какого размера рассчитывать
const uint N_MAX = (N <= SHARED_SIZE) ? N : SHARED_SIZE;

shared complex shared_data[SHARED_SIZE];

void copy_global_to_shared()
{
        for (uint local = gl_LocalInvocationID.x, global = gl_WorkGroupID.x * SHARED_SIZE + gl_LocalInvocationID.x;
             local < SHARED_SIZE && global < MAX_DATA_SIZE; local += gl_LocalGroupSizeARB.x, global += gl_LocalGroupSizeARB.x)
        {
                if (REVERSE_INPUT)
                {
                        uint i = global & N_MASK; // номер элемента внутри одного БПФ
                        shared_data[local] = global_data[global - i + bit_reverse(i, N_BITS)];
                }
                else
                {
                        shared_data[local] = global_data[global];
                }
        }
}

void copy_shared_to_global()
{
        for (uint local = gl_LocalInvocationID.x, global = gl_WorkGroupID.x * SHARED_SIZE + gl_LocalInvocationID.x;
             local < SHARED_SIZE && global < MAX_DATA_SIZE; local += gl_LocalGroupSizeARB.x, global += gl_LocalGroupSizeARB.x)
        {
                global_data[global] = (inv == 0) ? shared_data[local] : (shared_data[local] / N_MAX);
        }
}

void main()
{
        // Каждая группа потоков обрабатывает количество данных максимум BUFFER_SIZE.
        //  Может быть три случая размера ДПФ = N:
        // 1)   Размер каждого ДПФ кратно меньше DATA_SIZE.
        //    Тогда глобально обработать не больше MAX_DATA_SIZE.
        //    Например, может потребоваться выполнить 10 преобразований размером
        //    по 16 элементов с размером DATA_SIZE = 128, то есть 8 преобразований
        //    на первую группу и на вторую группу только 2 преобразования, а не 8.
        // 2)  Размер каждого ДПФ равен DATA_SIZE.
        // 3)  Размер каждого ДПФ кратно больше DATA_SIZE. Тогда рассчитывается
        //     частично до DATA_SIZE и без BitReverse на входных данных.

        // Проверка ошибки запуска. Нужно, чтобы на 2 элемента было не больше одного потока.
        if (gl_LocalGroupSizeARB.x > SHARED_SIZE / 2)
        {
                return;
        }
        // Проверка ошибки на лишнее число групп потоков.
        if (MAX_DATA_SIZE <= gl_WorkGroupID.x * SHARED_SIZE)
        {
                return;
        }

        copy_global_to_shared();

        // Один поток обрабатывает 2 элемента, поэтому >> 1.
        uint max_local = min(SHARED_SIZE, MAX_DATA_SIZE - gl_WorkGroupID.x * SHARED_SIZE) >> 1;

        // первоначально M = 2, поэтому просто PI
        float_point Two_PI_Div_M = (inv != 0) ? PI : -PI;

        for (uint M_2 = 1; M_2 < N_MAX; M_2 <<= 1, Two_PI_Div_M *= 0.5)
        {
                barrier();

                for (uint local = gl_LocalInvocationID.x; local < max_local; local += gl_LocalGroupSizeARB.x)
                {
                        // номер внутри отдельного БПФ
                        uint idx = local & (M_2 - 1); // это равно local % M_2
                        // смещение блока БПФ в массиве
                        uint base = (local - idx) << 1;

                        uint index_t = base + idx;
                        uint index_u = index_t + M_2;

                        complex v_t = shared_data[index_t];
                        complex v_u = shared_data[index_u];

                        complex twiddle_factor = complex(cos(Two_PI_Div_M * idx), sin(Two_PI_Div_M * idx));

                        complex k = mul(twiddle_factor, v_u);

                        shared_data[index_t] = v_t + k;
                        shared_data[index_u] = v_t - k;
                }
        }

        barrier();

        copy_shared_to_global();
}

#endif
